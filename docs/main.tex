\section{Използвани езици и технологии}

\input{used_stack/rust}

% \subsection{PDF}
% PDF е файлов формат създаден от Adobe през 1992г. предназначен да бъде преносим
% документ, независим от хардуера и софтуера. Всеки един PDF файл съдържа пълно
% описание на начина по който трябва да изглежда документа \cite{PDF_Wikipedia}.
%
% \subsubsection{Технически детайли}
% PDF най-често е комбинация от векторни графики и текст.
%
% В по-нови ревизии на PDF станзарта, документите могат да имат линкове които можем да отворим и подръжка за plugin-и.

\input{used_stack/egui}

\input{used_stack/genpdf}

\section{Подготовка}
Преди да започнем с разработката на софтуера трябва да настроим нашата среда за
действието. Тя включва Rust компилатора, текстов редактор (IDE) и Git за
контрол на версиитe.

\input{setup/rust-install}
\input{setup/text-editor}
\input{setup/git}

\section{Разработка}

\subsection{Създаване на проекта}
За да създадем нов Rust проект, първо трябва до отворим конзолата и да изпълним следната команда:
\begin{lstlisting}
cargo new test-generator
\end{lstlisting}

Тя ще генерира папка с името test-generator, в която се намира проекта. В src
папката се намират файловете, в които пишем кода, а в \textit{Cargo.toml} файла се намира
конфигурацията на проекта.

За да отворим проекта в текстов редактор, може да напишем комантадта `code .` за
да го отворим във Visual Studio Code или `nvim .` за да го отворим във Neovim.
 
\begin{figure}[!htb]
  \includegraphics[scale=0.60]{new-rust-project}
  \centering
  \caption{Файловата структура на Rust проекта}
  \label{fig:new-rust-project}
\end{figure}

\input{libraries}

\subsection{Създаване на структури от данни}
\subsubsection{Derive macro}
In Rust, a derive macro is a feature that allows you to automatically generate
code for a type by annotating it with a special attribute. The annotation tells
the Rust compiler to generate code for the annotated type based on a predefined
set of rules.

Derive macros are implemented as procedural macros, which means that they take
Rust code as input, transform it, and produce new Rust code as output. The
output can be either an implementation of a trait or a completely new type
definition.

To use a derive macro in Rust, you simply add the \#[derive] attribute followed
by the name of the macro to the definition of a struct, enum, or other type.
For example, to derive the Debug trait for a struct, you can write:

This will automatically generate an implementation of the Debug trait for
MyStruct, which will print out the values of its fields when the println!()
macro is used with an instance of the struct.

Derive macros are very powerful and can be used to generate code for many other
common traits and features, such as PartialEq, Eq, Clone, and Hash. They can
also be used to generate code for custom traits and features that you define
yourself.

Overall, derive macros are a powerful feature in Rust that allows you to write
less code and reduce boilerplate. They are easy to use and can be a great way
to generate common functionality for your types.

\subsubsection{serde skip}
When a field is annotated with \#[serde(skip)], serde will not include that
field in the serialized output, and will skip over it when deserializing input
data. This can be useful when you have a struct or enum with fields that you do
not want to include in the serialized output, or when you want to ignore
certain fields in input data.

\subsubsection{serde default}
When a field is annotated with \#[serde(default)], serde will use the default
value of the field if it is missing from the input data. This can be useful
when you have a struct or enum with optional fields, or when you want to ensure
that certain fields always have a value.

% TODO: #[serde(default = "default_options")]

\subsubsection{enum Question}
\begin{figure}[!htb]
  \includegraphics[scale=0.60]{data-questions.png}
  \centering
  \caption{Въпроси}
  \label{fig:data-questions}
\end{figure}

\subsection{Генериране на PDF}
\subsection{Създаване на графичен интерфейс}

\section{Оптимизации}
\begin{figure}[!htb]
  \includegraphics[scale=0.85]{optimization-size.png}
  \centering
  \caption{Разлика в размера при Debug и Release компилиране}
  \label{fig:optimization-size}
\end{figure}

\section{Компилиране за различни платформи}
За да компилирате Rust за различни платформи, ще трябва да инсталирате
toolchain и след това компилираме проекта. За да видим различните видове
toolchain-и, можем да използваме следната команда:
rustup target list
Тази команда ще изведе имената за над 90 различни поддържани платформи, но ще
се фокусираме само върху Windows и Linux. Те отговарят на имената
"x86-64-pc-windows-gnu" и "x86\_64-unknown-linux-gnu".

За автоматичното компилиране и архивиране на файловете за различните платформи
можем да създадем един Bash скрипт [Фигура \ref{fig:cross-compile}]. Този
скрипт автоматично ще инсталира toolchain-a ако вече не е, компилира проекта и
създава zip архив със файла за изпълнение.

\begin{figure}[!htb]
  \includegraphics[scale=0.75]{cross-compile.png}
  \centering
  \caption{Bash скрипт за комилиране и архивиране на проекта}
  \label{fig:cross-compile}
\end{figure}

На 3ти ред във Фигура \ref{fig:cross-compile} дефинираме функция
\textit{build\_for} която приема като аргумени името на toolchain-a и името на
компилирания файл. Функцията компилира и проекта използвайки всички оптимизации
и го архивира във файл със същотот име като името на toolchain-a.

Тези архиви могат да бъдат разпространени в интернет и всеки потребител да
изтегли съответната версия за неговата платформа и да използва софтуерния
продукт.


% [x] cargo new test-generator
% [x] open in text editor
% [ ] import libraries
%     [x] clap
%     [x] serde
%     [x] toml
%     [x] genpdf
%     [ ] egui
%     [ ] egui-notify
% [ ] create data structures
%     [ ] Project
%         [ ] Question
%             [ ] SelectionQuestion
%             [ ] InputQuestion
% [x] create command line arguments (clap)
%     [x] describe what clap is and how it works
% [ ] create pdf generator
%     [ ] create elements
%         [ ] AlphabeticOrderedList
%         [ ] CharRepeat
%         [ ] SplitElement
%     [ ] setting up the pdf library
%     [ ] generating header
%     [ ] generating questions
%     [ ] generating footer
% [ ] create gui
%     [ ] create questions tab
%     [ ] create configuration tab
%     [ ] create settings tab
% [ ] optimizing builds
% [ ] building for different platforms (MacOS, Windows & Linux)

\section{Използвани езици и технологии}

\input{used_stack/rust}

% \subsection{PDF}
% PDF е файлов формат създаден от Adobe през 1992г. предназначен да бъде преносим
% документ, независим от хардуера и софтуера. Всеки един PDF файл съдържа пълно
% описание на начина по който трябва да изглежда документа \cite{PDF_Wikipedia}.
%
% \subsubsection{Технически детайли}
% PDF най-често е комбинация от векторни графики и текст.
%
% В по-нови ревизии на PDF станзарта, документите могат да имат линкове които можем да отворим и подръжка за plugin-и.

\input{used_stack/egui}

\input{used_stack/genpdf}

\section{Подготовка}
Преди да започнем с разработката на софтуера трябва да настроим нашата среда за
действието. Тя включва Rust компилатора, текстов редактор (IDE) и Git за
контрол на версиитe.

\input{setup/rust-install}
\input{setup/text-editor}
\input{setup/git}

\section{Разработка}

\subsection{Създаване на проекта}
За да създадем нов Rust проект, първо трябва до отворим конзолата и да изпълним следната команда:
\begin{lstlisting}
cargo new test-generator
\end{lstlisting}

Тя ще генерира папка с името test-generator, в която се намира проекта. В src
папката се намират файловете, в които пишем кода, а в \textit{Cargo.toml} файла се намира
конфигурацията на проекта.

За да отворим проекта в текстов редактор, може да напишем комантадта `code .` за
да го отворим във Visual Studio Code или `nvim .` за да го отворим във Neovim.
 
\begin{figure}[!htb]
  \includegraphics[scale=0.60]{new-rust-project}
  \centering
  \caption{Файловата структура на Rust проекта}
  \label{fig:new-rust-project}
\end{figure}

\input{libraries}

\subsection{Създаване на структури от данни}
\subsubsection{Derive macro}
In Rust, a derive macro is a feature that allows you to automatically generate
code for a type by annotating it with a special attribute. The annotation tells
the Rust compiler to generate code for the annotated type based on a predefined
set of rules.

Derive macros are implemented as procedural macros, which means that they take
Rust code as input, transform it, and produce new Rust code as output. The
output can be either an implementation of a trait or a completely new type
definition.

To use a derive macro in Rust, you simply add the \#[derive] attribute followed
by the name of the macro to the definition of a struct, enum, or other type.
For example, to derive the Debug trait for a struct, you can write:

This will automatically generate an implementation of the Debug trait for
MyStruct, which will print out the values of its fields when the println!()
macro is used with an instance of the struct.

Derive macros are very powerful and can be used to generate code for many other
common traits and features, such as PartialEq, Eq, Clone, and Hash. They can
also be used to generate code for custom traits and features that you define
yourself.

Overall, derive macros are a powerful feature in Rust that allows you to write
less code and reduce boilerplate. They are easy to use and can be a great way
to generate common functionality for your types.

\subsubsection{serde skip}
When a field is annotated with \#[serde(skip)], serde will not include that
field in the serialized output, and will skip over it when deserializing input
data. This can be useful when you have a struct or enum with fields that you do
not want to include in the serialized output, or when you want to ignore
certain fields in input data.

\subsubsection{serde default}
When a field is annotated with \#[serde(default)], serde will use the default
value of the field if it is missing from the input data. This can be useful
when you have a struct or enum with optional fields, or when you want to ensure
that certain fields always have a value.

% TODO: #[serde(default = "default_options")]

\subsubsection{enum Question}
% TODO: explain why enum and whats the difference between InputQuestion and SelectionQuestion
Потребителят ще може да избира между два вида въпроси - с отворен отговор
(Input) и с избиране на подточки (Selection). Разликата между въпросите с
отворен отговор и избиране, са че за отворения отговор трябва да знаем колко
реда за отговор да бъдат дадени, а при въпроса с избиране трябва потребителя да
каже кои са правилните отговорите.

\begin{figure}[!htb]
  \includegraphics[scale=0.60]{data-questions.png}
  \centering
  \caption{Въпроси}
  \label{fig:data-questions}
\end{figure}

\subsection{Генериране на PDF}
За да генерираме PDF файл със genpdf библиотеката, трябва да създадем нов обект
от тип genpdf::Document. Конструктора на този обект иска да му бъде подадена
пътека към фонта, който да бъде използван за генерирането. Библиотеката ни
позволява да добавим и PageDecorator, чрез който можем да добавим поле около
страницата, заглавия и footer-и за номера на страницата. В този случай ще
използваме само полето около страницата.

След като сме подготвили обекта, който представлява PDF документа, можем да
започнем да добавяме нашите собствени елементи. Първите такива елементе ще
бъдат заглавието на теста, името на ученика, клас и номер в клас.
Заглавието на теста ще е с най-големия шрифт и ще е центриран, а под него
името, класа и номер на един ред.

% TODO: explain SplitElement?

\subsection{Създаване на графичен интерфейс}
Най-важната част от графичният интерфейс са табовете. Чрез тях се избира коя
част от графичния интерфейс да бъде показана - въпростие, конфигурацията на
проекта или настройките на графичния интерфейс.

За да знаем кой от трите таба е отворен използваме Rust enum. Egui библиотеката
ни позволява директно да и подадем глобален обект от този тип и тя автоматично
ще му смени варината когато наякой бутон е натиснат [Фигура
\ref{fig:gui-tab-selection}]. А във функцията който изобразява елементите
използваме match за да извикаме съответната функция за избраният таб [Фигура
\ref{fig:gui-match-tab}].

\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.75]{gui-tab-selection.png}
    \caption{Flower one.}
    \label{fig:gui-tab-selection}
\end{figure}
\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.65]{gui-match-tab.png}
    \caption{Flower two.}
    \label{fig:gui-match-tab}
\end{figure}

\newpage

\subsubsection{Уведомления}
За да съобщим на потребителя за статуса на програмата ще използваме egui-notify
библиотеката. Тя предоставя обект, който съдържа няколко метода: info, success, warning и error.
Тези методи ще покажат на потребителя различните видове уведомления.
\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.65]{gui-notify.png}
    \caption{Различните видове уведомления от egui-notify}
    \label{fig:gui-match-tab}
\end{figure}

\input{optimizations}
\input{cross-compile}

% [x] cargo new test-generator
% [x] open in text editor
% [ ] import libraries
%     [x] clap
%     [x] serde
%     [x] toml
%     [x] genpdf
%     [ ] egui
%     [ ] egui-notify
% [ ] create data structures
%     [ ] Project
%         [ ] Question
%             [ ] SelectionQuestion
%             [ ] InputQuestion
% [x] create command line arguments (clap)
%     [x] describe what clap is and how it works
% [ ] create pdf generator
%     [ ] create elements
%         [ ] AlphabeticOrderedList
%         [ ] CharRepeat
%         [ ] SplitElement
%     [ ] setting up the pdf library
%     [ ] generating header
%     [ ] generating questions
%     [ ] generating footer
% [ ] create gui
%     [x] tab selection
%     [ ] create questions tab
%     [ ] create configuration tab
%     [ ] create settings tab
%     [ ] toasts (egui notify)
% [x] optimizing builds
% [x] building for different platforms (MacOS, Windows & Linux)

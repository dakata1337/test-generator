\section{Използвани езици и технологии}

\input{used_stack/rust}

% \subsection{PDF}
% PDF е файлов формат създаден от Adobe през 1992г. предназначен да бъде преносим
% документ, независим от хардуера и софтуера. Всеки един PDF файл съдържа пълно
% описание на начина по който трябва да изглежда документа \cite{PDF_Wikipedia}.
%
% \subsubsection{Технически детайли}
% PDF най-често е комбинация от векторни графики и текст.
%
% В по-нови ревизии на PDF станзарта, документите могат да имат линкове които можем да отворим и подръжка за plugin-и.

\input{used_stack/egui}

\input{used_stack/genpdf}

\section{Подготовка}
Преди да започнем с разработката на софтуера трябва да настроим нашата среда за
действието. Тя включва Rust компилатора, текстов редактор (IDE) и Git за
контрол на версиитe.

\input{setup/rust-install}
\input{setup/text-editor}
\input{setup/git}

\section{Разработка}

\subsection{Създаване на проекта}
За да създадем нов Rust проект, първо трябва до отворим конзолата и да изпълним следната команда:
\begin{lstlisting}
cargo new test-generator
\end{lstlisting}

Тя ще генерира папка с името test-generator, в която се намира проекта. В src
папката се намират файловете, в които пишем кода, а в \textit{Cargo.toml} файла се намира
конфигурацията на проекта.

За да отворим проекта в текстов редактор, може да напишем комантадта `code .` за
да го отворим във Visual Studio Code или `nvim .` за да го отворим във Neovim.
 
\begin{figure}[!htb]
  \includegraphics[scale=0.60]{new-rust-project}
  \centering
  \caption{Файловата структура на Rust проекта}
  \label{fig:new-rust-project}
\end{figure}

\input{libraries}

\subsection{Създаване на структури от данни}
Най-важната част от програмата е състоянието на теста. За да пазим това състояние
и да го подавеме във функции трубва да създадем структурите от данни, които могат
да бъдат сериализирани и десериализирани в файлови формати.

За да кажем на Serde библиотеката как да форматира структурите от данни, можем
да използваме Deserialize/Serialize Derive макрото предоставено от библиотеката
[Фигура \ref{fig:data-questions}].

\subsubsection{Какво е Derive макро?}
В Rust Derive макротата са совойство на езика, което ни позволява автоматично
да генерирате код за тип, като го анотирате със специален атрибут. Анотацията
казва на Rust компилаторът автоматично да генерира код за анотирания тип въз
основа на предварително дефиниран набор от правила.

Derive макротата са имплементиране като процедурни макрота, което означава, че
те вземат Rust код като вход, трансформират го и създайте нов Rust код като
изход. Изходът може да бъде или реализация на интерфейс, или напълно нов
тип.

За да използваме тези макрота просто трябва да анотираме структурите от данни
с \#[derive(Serialize, Deserialize)] атрибута и Rust автоматично ще ни генерира
кода за преобразуване на информацията.

Derive макротата са много мощен инструмент който може да бъде използван за генериране
на код и за други интерфейси като например PartialEq и Eq за сравнение на обекти,
Clone за копиране на обекти и Hash за използването на обекта в хеш таблици.

\subsubsection{serde skip}
Когато едно поле (променлива) е анотирана с \#[serde(skip)], казваме на Serde че
не искаме това поле да бъде сериализирано\/десериализирано, а да бъде порпуснато.
Това може да бъде полезно когато не искаме да запазваме някоя променлива във файл,
като например състоянието на графичния интерфейс.

\subsubsection{serde default}
Когато едно поле (променлива) е анотирана с \#[serde(default)], казваме на
Serde да използва стойноста по подразбиране на даденото поле ако то не е
налично във входните данни. Това може да бъде полезно, когато имате структури с
незадължителни полета или когато искате да гарантирате, че определени полета
винаги имат стойност. 

Тази анотация също ни позволява да подадем име на функция която да се изпълни
вместо използването на стойноста по подразбиране. Тази функционалност е използвана
за да бъде пороменена началната стойност на точките за въпросите [Фигура
\ref{fig:data-questions}]

\subsubsection{enum Question}
Потребителят ще може да избира между два вида въпроси - с отворен отговор
(Input) и с избиране на подточки (Selection). Разликата между въпросите с
отворен отговор и избиране, са че за отворения отговор трябва да знаем колко
реда за отговор да бъдат дадени, а при въпроса с избиране трябва потребителя да
каже кои са правилните отговорите.

\begin{figure}[!htb]
  \includegraphics[scale=0.60]{data-questions.png}
  \centering
  \caption{Реализация на структурите от данни за въпросите}
  \label{fig:data-questions}
\end{figure}

\subsection{Генериране на PDF}
За да генерираме PDF файл със genpdf библиотеката, трябва да създадем нов обект
от тип \textit{genpdf::Document}. Конструктора на този обект иска да му бъде подадена
пътека към фонта, който да бъде използван за генерирането. Библиотеката ни
позволява да добавим и PageDecorator, чрез който можем да добавим поле около
страницата, заглавия и footer-и за номера на страницата. В този случай ще
използваме само полето около страницата.

След като сме подготвили обекта, който представлява PDF документа, можем да
започнем да добавяме нашите собствени елементи. genpdf библиотекта разполага
с моного различни готови елементи, но се налага да имплементираме някои нови:
\begin{itemize}
    \item AlphabeticOrderedList - сипък от подточки, който поддържа различни езици.
        Този елемент приема първата буква от която ще бори и има функция която позволява
        да се добавят нови подточки. Елемента имплементира \textit{genpdf::Element} интерфейса,
        който има функция \textit{render}. Тази функция приема като аргумент контекст
        (информация за документа), свободното място за изобразяване на елемента
        и стила на форматиране на документа. При извикването на \textit{render}
        функцията, програмата минава през всеки един отговор и го добавя в
        документа като слага в началото на елемента съответната буква.
        Това се постига благодарение на начина, по който се подредени буквите при UTF-8
        стандарта. Всяка една буква отговаря на определено число, което ни позволява да
        обърнем буквата в число, да добавим едно и да обърнем числото обратно в буква.
        По този начин можем да изпишем азбуката с for цикъл.
        [Фигура \ref{fig:genpdf-list}]

    \item CharRepeat - това е елемент, на който му се подава буква и той я
        повтаря до края на страницата. Този елемент се използва при
        генерирането на редовете за свободен отговор. Имплементацията е много
        проста. Създаваме обект, който да имплементира \textit{genpdf::Element}
        интерфейса, който има функция \textit{render}. При нейното извикване изчисляваме
        каква е дължината на подадената буква и колко пъти можем да я съберем в един
        ред (N). След това изобразяваме буквата N на брой пъти.
        [Фигура \ref{fig:genpdf-charrepeat}]

    \item SplitElement - това е елемент, който приема други два елемента и
        число с плаваща запетая (float). Той се използва когато трябва два
        елемента да си поделят един ред. Ако числото с плаваща запетая е 0.5
        това означава, че двата елемнта ще си разделят свободното място по
        равно, но ако числото е 0.0 първият елемент може да използва колкото му
        е необходимо а останалото място остава за втория. Използва се при
        полето за име, клас и номер в клас на ученика.
        [Фигура \ref{fig:genpdf-split}]
\end{itemize}

Генерирането на PDF документа е разделено на три основни части: заглавие,
въпроси и footer. Всяка част е отделена в отделна функция.

Във функцията за заглавната част, създаваме параграф със заглавието на теста.
Този параграф е центриран и бива добавен в документа.
След това биват създадени три параграфа за името, класа и новера в клас на
ученика. Те биват добавени в \textit{SplitElement} за да бъдат подредени на
един ред.

След като елементите са подготвени, те биват добавени в документа и се добавя
\textit{Break} елемент, който има за цел да раздели заглавната част от
въпросите.

Следващата част от генерирането на PDF документа са въпросите. Преди тяхното
генериране те биват подготвени като например когато потребителя е избрал
опцията за разбъркване на въпросите. Това става чрез вградената функция на списъците в Rust \textit{shuffle}.

След като са подготвени въпросите те биват обходени един по един. За всеки въпрос
бива генериран елемент, който да показва броя точки за дадения въпрос и има
достатъчно място за проверяващия да нанесе получения броя точки.

В зависимост от това дали въпроса е с отворен отговор или избиране на подточки,
се генерират необходимите редове за свободен отговор или подточките.

Последната част от генерирането e footer-aр при който се събират точките от
всички въпроси и се изчислява нужното място за нанасянето на точките. Това може
да бъде постигнато използвайки логаритмите от математиката. Тъй като хората
броим в десетичната бройна система трябва да използваме десетичен логаритъм.

Rust разполага с log10 функция, но тя все още е в изпитателен срок и е нестабилна.
За да използваме логаритмичните функции можем да добавим \textit{ilog} библиотеката.
 
\subsection{Създаване на графичен интерфейс}
Най-важната част от графичният интерфейс са табовете. Чрез тях се избира коя
част от графичния интерфейс да бъде показана - въпростие, конфигурацията на
проекта или настройките на графичния интерфейс.

За да знаем кой от трите таба е отворен използваме Rust enum. Egui библиотеката
ни позволява директно да и подадем глобален обект от този тип и тя автоматично
ще му смени варината когато наякой бутон е натиснат [Фигура
\ref{fig:gui-tab-selection}]. А във функцията който изобразява елементите
използваме match за да извикаме съответната функция за избраният таб [Фигура
\ref{fig:gui-match-tab}].

\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.85]{gui-tab-selection.png}
    \caption{Код за избиране на таб}
    \label{fig:gui-tab-selection}
\end{figure}
\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.75]{gui-match-tab.png}
    \caption{Код за изобразяване на таб}
    \label{fig:gui-match-tab}
\end{figure}

\subsubsection{Уведомления}
За да съобщим на потребителя за статуса на програмата ще използваме egui-notify
библиотеката. Тя предоставя обект, който съдържа няколко метода: info, success, warning и error.
Тези методи ще покажат на потребителя различните видове уведомления.
\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.70]{gui-notify.png}
    \caption{Различните видове уведомления от egui-notify}
    \label{fig:gui-match-tab}
\end{figure}

\input{optimizations}
\input{cross-compile}

% [x] cargo new test-generator
% [x] open in text editor
% [ ] import libraries
%     [x] clap
%     [x] serde
%     [x] toml
%     [x] genpdf
%     [ ] egui
%     [ ] egui-notify
% [ ] create data structures
%     [x] Project
%         [x] Question
%             [x] SelectionQuestion
%             [x] InputQuestion
%     [ ] 
% [x] create command line arguments (clap)
%     [x] describe what clap is and how it works
% [ ] create pdf generator
%     [x] create elements
%         [x] AlphabeticOrderedList
%         [x] CharRepeat
%         [x] SplitElement
%     [x] setting up the pdf library
%     [ ] generating header
%     [ ] generating questions
%     [ ] generating footer
% [ ] create gui
%     [x] tab selection
%     [ ] create questions tab
%     [ ] create configuration tab
%     [ ] create settings tab
%     [x] toasts (egui notify)
% [x] optimizing builds
% [x] building for different platforms (MacOS, Windows & Linux)
